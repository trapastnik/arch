<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
  />
  <title>–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –ø–ª–∞–Ω—à–µ—Ç–æ–≤ ‚Äî ONNX Web</title>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: #0f1115;
      color: #e6e6e6;
      font: 15px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
    }
    .wrap { max-width: 720px; margin: 0 auto; padding: 10px 12px; }
    h1 { font-size: 17px; font-weight: 600; margin: 0 0 8px; text-align: left; }
    .card {
      background: #171a21;
      border: 1px solid #262a33;
      border-radius: 12px;
      padding: 10px;
      box-shadow: 0 4px 18px rgba(0,0,0,.25);
    }
    .video-wrap {
      position: relative;
      width: 100%;
      border-radius: 10px;
      overflow: hidden;
      background: #000;
    }
    video {
      display: block;
      width: 100%;
      max-height: 50vh;
      border-radius: 10px;
      background: #000;
    }
    /* —Ö–æ–ª—Å—Ç –ø–æ–≤–µ—Ä—Ö –≤–∏–¥–µ–æ –¥–ª—è —Ä–∞–º–∫–∏ */
    canvas#overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; margin: 8px 0 6px; align-items: center; }
    button {
      padding: 8px 12px; border-radius: 9px; border: 1px solid #2b3140;
      background: #222a36; color: #fff; cursor: pointer; font-size: 14px;
    }
    button[disabled]{ opacity:.6; cursor:not-allowed; }
    label.switch { font-size: 13px; display:flex; align-items:center; gap:6px; opacity:.9; }
    #result { font-size: 16px; margin: 6px 0 2px; }
    #sub { opacity:.8; font-size:13px; margin-bottom:4px; min-height:18px; }

    #progressWrap {
      display:none; height:6px; background:#11151c; border:1px solid #283041;
      border-radius:999px; overflow:hidden; margin:4px 0 6px;
    }
    #progress { height:100%; width:0%; background:#4a90e2; }

    .topk-row { display:flex; align-items:center; gap:8px; flex-wrap:nowrap; overflow-x:auto; -webkit-overflow-scrolling:touch; padding-bottom:2px; }
    .label { font-size:13px; opacity:.85; white-space:nowrap; }
    .pill { display:inline-block; border:1px solid #2b3140; border-radius:999px; padding:3px 8px; white-space:nowrap; font-size:12px; margin-right:4px; }

    details { margin-top:6px; }
    details>summary { list-style:none; cursor:pointer; font-size:12px; opacity:.75; }
    details>summary::-webkit-details-marker{ display:none; }
    pre {
      white-space:pre-wrap; word-break:break-word; background:#11151c; border:1px solid #283041;
      padding:8px; border-radius:8px; font-size:12px; max-height:22vh; overflow:auto; margin-top:6px;
    }
    .footer { opacity:.6; font-size:11.5px; margin-top:8px; }
    @media (max-width:390px){
      #result{font-size:15px} button{font-size:13px;padding:7px 10px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üì∑ –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –ø–ª–∞–Ω—à–µ—Ç–æ–≤ (ONNXRuntime Web)</h1>

    <div class="card">
      <div class="video-wrap">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="controls">
        <button id="btnStart">–°—Ç–∞—Ä—Ç –∫–∞–º–µ—Ä—ã</button>
        <button id="btnStop" disabled>–°—Ç–æ–ø</button>
        <button id="btnFlip">–ü–æ–º–µ–Ω—è—Ç—å –∫–∞–º–µ—Ä—É</button>
        <label class="switch"><input id="chkAutoBox" type="checkbox" checked /> –ê–≤—Ç–æ-—Ä–∞–º–∫–∞</label>
      </div>

      <div id="result">–ì–æ—Ç–æ–≤–æ –∫ –∑–∞–ø—É—Å–∫—É‚Ä¶</div>
      <div id="sub" class="muted">–ó–∞–≥—Ä—É–∑–∏—Ç—Å—è –º–æ–¥–µ–ª—å –∏ –∫–∞—Ä—Ç–∞ –∫–ª–∞—Å—Å–æ–≤.</div>

      <div id="progressWrap"><div id="progress"></div></div>

      <div class="topk-row"><span class="label">–¢–æ–ø-3:</span><span id="topk"></span></div>

      <details>
        <summary>–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞</summary>
        <pre id="diag"></pre>
      </details>

      <div class="footer">
        HTTPS –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω (GitHub Pages –æ–∫). –ù–∞ iOS –∫–∞–º–µ—Ä–∞ —Å—Ç–∞—Ä—Ç—É–µ—Ç —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –∫–ª–∏–∫–∞.
      </div>
    </div>
  </div>

<script>
/** ========= –ü–£–¢–ò ========= */
const MODEL_URL = 'web_model/model.onnx';
const MAP_URL   = 'class_mapping.json';

/** ========= –ö–û–ù–°–¢–ê–ù–¢–´ ========= */
const INPUT_SIZE = 224;          // —Ä–∞–∑–º–µ—Ä –≤—Ö–æ–¥–∞ –º–æ–¥–µ–ª–∏
const LOOP_INTERVAL_MS = 150;    // —á–∞—Å—Ç–æ—Ç–∞ –∏–Ω—Ñ–µ—Ä–µ–Ω—Å–∞
const EDGE_SIZE = 160;           // —Ä–∞–∑–º–µ—Ä –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ —Ä–∞–º–∫–∏

/** ========= –ì–õ–û–ë–ê–õ ========= */
let session = null, mapping = null;
let video = null, stream = null, overlay = null, octx = null;
let usingBack = true, rafId = null, lastTs = 0;
let INPUT_NAME = null, OUTPUT_NAME = null, useNCHW = false;
let autoBox = true;
let lastBox = null; // {x,y,w,h} –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö overlay-canvas

/** ========= –£–¢–ò–õ–ò–¢–´ ========= */
const $ = s => document.querySelector(s);
const setText = (id, t) => document.getElementById(id).innerText = t;
function logDiag(obj){ const el=$('#diag'); el.textContent += (typeof obj==='string'?obj:JSON.stringify(obj,null,2))+'\n'; }
function setStatus(txt, pct=null){
  setText('result', txt);
  const wrap = $('#progressWrap'), bar = $('#progress');
  if (pct==null){ wrap.style.display='none'; }
  else { wrap.style.display='block'; bar.style.width = `${Math.max(0,Math.min(100,Math.round(pct*100)))}%`; }
}

/** ========= –ó–ê–ì–†–£–ó–ö–ê –° –ü–†–û–ì–†–ï–°–°–û–ú ========= */
async function fetchModelWithProgress(url, onProgress){
  const resp = await fetch(url); if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
  const total = +resp.headers.get('Content-Length') || 0;
  const reader = resp.body?.getReader?.();
  if(!reader){ const ab=await resp.arrayBuffer(); onProgress?.(1); return new Uint8Array(ab); }
  const chunks=[]; let rec=0;
  for(;;){ const {done,value}=await reader.read(); if(done) break; chunks.push(value); rec+=value.byteLength; if(total) onProgress?.(rec/total); }
  const blob=new Blob(chunks); const ab=await blob.arrayBuffer(); onProgress?.(1); return new Uint8Array(ab);
}

/** ========= –ú–û–î–ï–õ–¨ + –ú–ê–ü–ü–ò–ù–ì ========= */
async function loadAll(){
  setStatus('–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–∞–Ω—Ç–∞–π–º–∞‚Ä¶'); await new Promise(r=>setTimeout(r,40));
  setStatus('–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏‚Ä¶',0);
  const modelBytes = await fetchModelWithProgress(MODEL_URL, p=>setStatus(`–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏‚Ä¶ ${Math.round(p*100)}%`,p));

  setStatus('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–∏‚Ä¶');
  session = await ort.InferenceSession.create(modelBytes,{ executionProviders:['wasm'], graphOptimizationLevel:'all' });

  INPUT_NAME  = session.inputNames?.[0] ?? null;
  OUTPUT_NAME = session.outputNames?.[0] ?? null;
  let dims=null;
  try{
    const meta=session.inputMetadata;
    if(meta){
      dims = typeof meta.get==='function' && INPUT_NAME ? meta.get(INPUT_NAME)?.dimensions
           : (INPUT_NAME && meta[INPUT_NAME]) ? meta[INPUT_NAME].dimensions
           : null;
    }
  }catch(e){ logDiag('meta read error: '+(e?.message||e)); }
  useNCHW = (Array.isArray(dims)&&dims.length===4&&dims[1]===3); // –∏–Ω–∞—á–µ NHWC
  logDiag({inputName:INPUT_NAME, outputName:OUTPUT_NAME, inputDims:dims, useNCHW});

  setStatus('–ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ä—Ç—ã –∫–ª–∞—Å—Å–æ–≤‚Ä¶');
  mapping = await fetch(MAP_URL).then(r=>r.json());

  setStatus('–ü—Ä–æ–≥—Ä–µ–≤ –º–æ–¥–µ–ª–∏‚Ä¶');
  try{
    const zeros=new Float32Array(INPUT_SIZE*INPUT_SIZE*3);
    const warm=useNCHW ? new ort.Tensor('float32',zeros,[1,3,INPUT_SIZE,INPUT_SIZE])
                       : new ort.Tensor('float32',zeros,[1,INPUT_SIZE,INPUT_SIZE,3]);
    await session.run({[INPUT_NAME]:warm});
  }catch(e){ logDiag('warmup: '+(e?.message||e)); }

  setStatus('–ú–æ–¥–µ–ª—å –≥–æ—Ç–æ–≤–∞. –ù–∞–∂–º–∏ ¬´–°—Ç–∞—Ä—Ç –∫–∞–º–µ—Ä—ã¬ª.', null);
  setText('sub', `–í—Ö–æ–¥: ${INPUT_SIZE}√ó${INPUT_SIZE}, –∫–ª–∞—Å—Å–æ–≤: ${Object.keys(mapping).length} ‚Ä¢ –§–æ—Ä–º–∞—Ç: ${useNCHW?'NCHW':'NHWC'}`);
}

/** ========= –ö–ê–ú–ï–†–ê ========= */
async function startCamera(){
  if(stream) await stopCamera();
  const constraints={ video:{ facingMode: usingBack?{ideal:'environment'}:'user' }, audio:false };
  stream = await navigator.mediaDevices.getUserMedia(constraints);
  video = $('#video'); video.setAttribute('playsinline',''); video.srcObject=stream; video.muted=true; await video.play();

  // –ø–æ–¥–≥–æ—Ç–æ–≤–∏–º overlay
  overlay = $('#overlay'); octx = overlay.getContext('2d');
  resizeOverlay(); // –ø–æ–¥–æ–≥–Ω–∞—Ç—å —Ä–∞–∑–º–µ—Ä —Ö–æ–ª—Å—Ç–∞ –ø–æ–¥ –≤–∏–¥–µ–æ
  window.addEventListener('resize', resizeOverlay, { passive:true });
}
async function stopCamera(){
  if(stream){ for(const t of stream.getTracks()) t.stop(); }
  stream=null; if(video) video.srcObject=null;
  window.removeEventListener('resize', resizeOverlay);
}
function resizeOverlay(){
  if(!video||!overlay) return;
  const rect = video.getBoundingClientRect();
  overlay.width = rect.width * devicePixelRatio;
  overlay.height= rect.height* devicePixelRatio;
  lastBox = null;
}

/** ========= –ü–û–ò–°–ö –†–ê–ú–ö–ò =========
 * –ò–¥–µ—è: —É–º–µ–Ω—å—à–∏—Ç—å –∫–∞–¥—Ä –¥–æ EDGE_SIZE, –ø–æ—Å—á–∏—Ç–∞—Ç—å –∫–∞—Ä—Ç—É –≥—Ä–∞–Ω–∏—Ü (Sobel),
 * –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏ –≤—ã–±—Ä–∞—Ç—å –æ–∫–Ω–æ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏
 * —Å –∞—Å–ø–µ–∫—Ç–æ–º –æ–∫–æ–ª–æ –ø–ª–∞–Ω—à–µ—Ç–∞ (1.33‚Äì1.6), –∫–æ—Ç–æ—Ä–æ–µ –¥–∞—ë—Ç –º–∞–∫—Å–∏–º—É–º —Å—É–º–º—ã.
 */
function findTabletBox(v){
  if(!overlay) return null;
  const vw = overlay.width, vh = overlay.height; // –≤ CSS-–ø–∏–∫—Å–µ–ª—è—Ö * dpr
  // –±–µ—Ä—ë–º bitmap –∏–∑ –≤–∏–¥–µ–æ –≤ –º–∞–ª–µ–Ω—å–∫–∏–π –±—É—Ñ–µ—Ä
  const s = EDGE_SIZE, cvs = document.createElement('canvas');
  cvs.width=s; cvs.height=s * (vh/vw); // —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ –≤–∏–¥–∞
  const ctx = cvs.getContext('2d', { willReadFrequently:true });
  ctx.drawImage(v, 0, 0, cvs.width, cvs.height);
  const { data, width:W, height:H } = ctx.getImageData(0,0,cvs.width,cvs.height);

  // –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã Sobel
  const gxK = [-1,0,1,-2,0,2,-1,0,1];
  const gyK = [-1,-2,-1,0,0,0,1,2,1];
  const gray = new Float32Array(W*H);
  for(let i=0,p=0;i<gray.length;i++){ const r=data[p++],g=data[p++],b=data[p++]; p++; gray[i]=(0.299*r+0.587*g+0.114*b); }
  const mag = new Float32Array(W*H);
  for(let y=1;y<H-1;y++){
    for(let x=1;x<W-1;x++){
      let gx=0, gy=0, k=0;
      for(let j=-1;j<=1;j++){
        for(let i=-1;i<=1;i++){
          const v = gray[(y+j)*W + (x+i)];
          gx += v * gxK[k];
          gy += v * gyK[k];
          k++;
        }
      }
      const m = Math.hypot(gx,gy);
      mag[y*W + x] = m;
    }
  }
  // –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö —Å—É–º–º –ø–æ –æ–∫–Ω—É
  const ii = new Float32Array((W+1)*(H+1));
  for(let y=1;y<=H;y++){
    let rowSum=0;
    for(let x=1;x<=W;x++){
      rowSum += mag[(y-1)*W + (x-1)];
      ii[y*(W+1)+x] = ii[(y-1)*(W+1)+x] + rowSum;
    }
  }
  const sumRect = (x0,y0,x1,y1)=>{ // –≤–∫–ª—é—á–∞—è x1,y1
    return ii[y1*(W+1)+x1] - ii[y0*(W+1)+x1] - ii[y1*(W+1)+x0] + ii[y0*(W+1)+x0];
  };

  // –ø–µ—Ä–µ–±–æ—Ä –æ–∫–æ–Ω —Å –∞—Å–ø–µ–∫—Ç–æ–º ~–ø–ª–∞–Ω—à–µ—Ç–∞
  const aspects = [1.33, 1.5, 1.6];
  let best = {score:-1, x:0,y:0,w:W,h:H};
  for(const ar of aspects){
    // –º–∞—Å—à—Ç–∞–±—ã –æ–∫–Ω–∞ –æ—Ç 45% –¥–æ 95% —à–∏—Ä–∏–Ω—ã, —à–∞–≥–∞–º–∏
    for(let w = Math.floor(W*0.45); w <= Math.floor(W*0.95); w += Math.max(8, Math.floor(W*0.08))){
      const h = Math.floor(w / ar);
      if(h<16 || h>H) continue;
      for(let x=1; x+w < W; x += Math.max(6, Math.floor(W*0.06))){
        for(let y=1; y+h < H; y += Math.max(6, Math.floor(H*0.06))){
          const s = sumRect(x, y, x+w, y+h) / (w*h); // —Å—Ä–µ–¥–Ω—è—è ‚Äú—Ä–µ–∑–∫–æ—Å—Ç—å‚Äù –æ–∫–Ω–∞
          if(s > best.score){ best={score:s, x, y, w, h}; }
        }
      }
    }
  }
  // –ø–µ—Ä–µ–≤–æ–¥ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ –ø–∏–∫—Å–µ–ª–∏ overlay (—É—á–∏—Ç—ã–≤–∞—è dpr –∏ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω)
  const dpr = devicePixelRatio;
  const scaleX = vw / W;
  const scaleY = vh / H;
  return {
    x: Math.max(0, Math.floor(best.x * scaleX)),
    y: Math.max(0, Math.floor(best.y * scaleY)),
    w: Math.max(1, Math.floor(best.w * scaleX)),
    h: Math.max(1, Math.floor(best.h * scaleY)),
  };
}

/** ========= –û–¢–†–ò–°–û–í–ö–ê –†–ê–ú–ö–ò ========= */
function drawBox(box){
  if(!octx || !overlay) return;
  octx.clearRect(0,0,overlay.width,overlay.height);
  if(!box) return;
  octx.lineWidth = 3 * devicePixelRatio;
  octx.strokeStyle = 'rgba(80,160,255,0.95)';
  octx.setLineDash([10*devicePixelRatio, 6*devicePixelRatio]);
  octx.strokeRect(box.x, box.y, box.w, box.h);
  octx.setLineDash([]);
}

/** ========= –ü–†–ï–ü–†–û–¶–ï–°–° ========= */
function preprocessToTensor(v){
  const W = INPUT_SIZE, H = INPUT_SIZE;
  // –µ—Å–ª–∏ –µ—Å—Ç—å –±–æ–∫—Å ‚Äî –±–µ—Ä—ë–º –µ–≥–æ ROI –∏–∑ –≤–∏–¥–µ–æ, –∏–Ω–∞—á–µ –≤–µ—Å—å –∫–∞–¥—Ä
  const cvs = document.createElement('canvas');
  cvs.width = W; cvs.height = H;
  const ctx = cvs.getContext('2d', { willReadFrequently:true });

  if (autoBox && lastBox && overlay){
    // –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã lastBox ‚Äî –≤ –ø–∏–∫—Å–µ–ª—è—Ö overlay (—É–º–Ω–æ–∂–µ–Ω–Ω—ã—Ö –Ω–∞ dpr).
    // –ü–µ—Ä–µ–≤–µ–¥—ë–º –∏—Ö –≤ CSS-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–∏–¥–µ–æ:
    const dpr = devicePixelRatio;
    const sx = lastBox.x / dpr, sy = lastBox.y / dpr;
    const sw = lastBox.w / dpr, sh = lastBox.h / dpr;
    // –†–∏—Å—É–µ–º ROI, —Ä–∞—Å—Ç—è–≥–∏–≤–∞—è –Ω–∞ 224√ó224
    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, W, H);
  } else {
    ctx.drawImage(video, 0, 0, W, H);
  }

  const { data } = ctx.getImageData(0, 0, W, H);
  const wh = W*H;

  if (useNCHW) {
    const floats = new Float32Array(wh*3);
    for (let i=0,p=0;i<wh;i++){
      const r=data[p++], g=data[p++], b=data[p++]; p++;
      floats[i]       = (r/127.5 - 1);
      floats[i+wh]    = (g/127.5 - 1);
      floats[i+2*wh]  = (b/127.5 - 1);
    }
    return new ort.Tensor('float32', floats, [1,3,H,W]);
  } else {
    const floats = new Float32Array(wh*3);
    for (let i=0,p=0,q=0;i<wh;i++){
      const r=data[p++], g=data[p++], b=data[p++]; p++;
      floats[q++] = (r/127.5 - 1);
      floats[q++] = (g/127.5 - 1);
      floats[q++] = (b/127.5 - 1);
    }
    return new ort.Tensor('float32', floats, [1,H,W,3]);
  }
}

/** ========= –ò–ù–§–ï–†–ï–ù–° ========= */
function topkSoftmax(logits, k=3){
  let maxL=-Infinity; for(let i=0;i<logits.length;i++) if(logits[i]>maxL) maxL=logits[i];
  let sum=0; const exps=new Float32Array(logits.length);
  for(let i=0;i<logits.length;i++){ const e=Math.exp(logits[i]-maxL); exps[i]=e; sum+=e; }
  const probs=new Float32Array(logits.length); for(let i=0;i<logits.length;i++) probs[i]=exps[i]/sum;
  const idxs=[...probs.keys()].sort((a,b)=>probs[b]-probs[a]);
  return { top1Idx: idxs[0], top1Prob: probs[idxs[0]], top3: idxs.slice(0,k).map(i=>({idx:i, prob:probs[i]})) };
}

async function predictLoop(ts){
  if (!lastTs || ts - lastTs >= LOOP_INTERVAL_MS) {
    lastTs = ts;
    try {
      // –æ–±–Ω–æ–≤–∏–º –±–æ–∫—Å —Ä–∞–∑ –≤ —Ü–∏–∫–ª (–¥–µ—à—ë–≤—ã–π –∞–Ω–∞–ª–∏–∑ –Ω–∞ —É–º–µ–Ω—å—à–µ–Ω–Ω–æ–º –∫–∞–¥—Ä–µ)
      if (autoBox) {
        lastBox = findTabletBox(video) || lastBox;
        drawBox(lastBox);
      } else {
        drawBox(null);
      }

      const x = preprocessToTensor(video);
      const out = await session.run({ [INPUT_NAME]: x });
      const logits = out[OUTPUT_NAME].data;
      const { top1Idx, top1Prob, top3 } = topkSoftmax(logits, 3);
      const name = mapping[String(top1Idx)] ?? `class_${top1Idx}`;
      setText('result', `üß© ${name} (${(top1Prob*100).toFixed(1)}%)`);
      setText('sub', `–ö–ª–∞—Å—Å #${top1Idx} ‚Ä¢ –§–æ—Ä–º–∞—Ç: ${useNCHW?'NCHW':'NHWC'}${autoBox?' ‚Ä¢ ROI: on':''}`);
      $('#topk').innerHTML = top3.map(({idx,prob})=>`<span class="pill">${mapping[String(idx)] ?? 'class_'+idx} ‚Äî ${(prob*100).toFixed(1)}%</span>`).join('');
    } catch (e) {
      setText('result','–û—à–∏–±–∫–∞ –∏–Ω—Ñ–µ—Ä–µ–Ω—Å–∞');
      setText('sub', e?.message || String(e));
      logDiag(e?.stack || String(e));
    }
  }
  rafId = requestAnimationFrame(predictLoop);
}

/** ========= UI ========= */
document.getElementById('btnStart').addEventListener('click', async ()=>{
  try{
    $('#btnStart').disabled = true;
    setStatus('–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞‚Ä¶');
    await loadAll();
    await startCamera();
    $('#btnStop').disabled = false;
    setStatus('–ö–∞–º–µ—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞. –†–∞—Å–ø–æ–∑–Ω–∞—ë–º‚Ä¶', null);
    rafId = requestAnimationFrame(predictLoop);
  }catch(e){
    $('#btnStart').disabled = false;
    setText('result','–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞');
    setText('sub', e?.message || String(e));
    logDiag(e?.stack || String(e));
  }
});
document.getElementById('btnStop').addEventListener('click', async ()=>{
  if (rafId) cancelAnimationFrame(rafId);
  await stopCamera();
  $('#btnStop').disabled = true;
  $('#btnStart').disabled = false;
  setStatus('–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.', null);
  drawBox(null);
});
document.getElementById('btnFlip').addEventListener('click', async ()=>{
  usingBack = !usingBack;
  if (stream){ await startCamera(); }
});
document.getElementById('chkAutoBox').addEventListener('change', (e)=>{
  autoBox = e.target.checked;
  if(!autoBox) drawBox(null);
});
</script>
</body>
</html>
